# 架构准则

## 整体架构模式
- 强制执行模块化 + MVVM + Clean Architecture：
  - Presentation：Jetpack ViewModel、LiveData/StateFlow、Navigation，配合 BaseActivity/BaseFragment/BaseViewModel。
  - Domain：UseCase + Repository 接口，纯 Kotlin、可测试。
  - Data：Repository 实现（网络 + Room）、缓存策略、数据映射。
- 功能按 Feature Module 拆分（视频流、个人主页、搜索等），公共能力沉淀在 `core/*`。
- 复用 Cursor 生成的标准化包结构、依赖注入骨架、Repository 模板、播放器接口，保持一致性。

## 根据场景选择合适的架构模式
- **插件式架构**：适用于需要动态扩展能力的场景，如播放器内核切换、AI 能力模块（清晰度切换、内容理解、字幕生成）、数据源适配器等。通过接口定义契约，实现类可插拔。
- **建造者模式**：适用于复杂对象构建，如播放器配置（ExoPlayer.Builder）、网络请求配置（Retrofit/OkHttp）、UI 组件构建等。
- **观察者模式**：充分利用 Kotlin Flow、LiveData、StateFlow 实现响应式编程。播放器状态变化、UI 事件、数据更新等场景优先使用观察者模式。
- **策略模式**：适用于算法可替换场景，如视频清晰度选择策略、缓存策略、网络重试策略、AI 推理策略等。
- **工厂模式**：适用于对象创建逻辑复杂或需要统一管理的场景，如播放器实例创建、Repository 创建、UseCase 创建等。
- **适配器模式**：适用于接口不兼容的场景，如不同播放器内核的统一接口适配、不同数据源的统一适配、第三方 SDK 的封装等。
- **单例模式**：谨慎使用，仅用于全局唯一资源，如播放器复用池、全局配置管理器、日志管理器等。

## 设计模式应用场景
- **播放器模块**：
  - 策略模式：不同播放器内核（ExoPlayer/ijkplayer）的统一接口
  - 观察者模式：播放状态、进度、错误事件的监听
  - 建造者模式：播放器配置构建
  - 工厂模式：播放器实例创建与复用池管理
- **数据层**：
  - 适配器模式：不同数据源（网络/本地缓存/内存）的统一接口
  - 策略模式：缓存策略（LRU/FIFO/时间过期）
  - 观察者模式：数据变化通知（Flow/LiveData）
- **UI 层**：
  - 观察者模式：ViewModel 与 View 的数据绑定
  - 建造者模式：复杂 UI 组件构建
  - 策略模式：不同交互手势的处理策略
- **AI 模块**：
  - 插件式架构：不同 AI 能力模块（清晰度切换/内容理解/字幕生成）
  - 策略模式：在线/离线推理策略、降级策略
  - 工厂模式：AI 模型加载与管理

## 播放器抽象层
- 创建统一的 `VideoPlayer` 接口，支持切换不同播放器内核（ExoPlayer/ijkplayer），便于未来扩展和维护。
- 使用策略模式实现播放器内核的可替换性。
- 使用观察者模式实现播放状态、进度、错误的监听机制。

## 视频播放生命周期管理
- 在 ViewModel 中管理播放器状态（播放/暂停、进度、清晰度），确保生命周期安全。
- 使用观察者模式（StateFlow/LiveData）同步播放器状态到 UI。
- 使用工厂模式管理播放器实例的创建与复用。

## 设计原则
- **单一职责原则**：每个类/模块只负责一个功能。
- **开闭原则**：对扩展开放，对修改关闭。通过接口和抽象类实现。
- **依赖倒置原则**：高层模块不依赖低层模块，都依赖抽象。Domain 层定义接口，Data 层实现。
- **接口隔离原则**：使用多个专门的接口，而不是单一的总接口。
- **里氏替换原则**：子类可以替换父类，保持行为一致性。
- **优先组合而非继承**：通过组合实现代码复用，提高灵活性。
