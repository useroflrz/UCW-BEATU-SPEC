## 核心原则
- 目标：实现沉浸式视频流 App，但更重要的是以架构、性能、交互和 AI 融合展示团队级工程能力，让评审一眼看到技术深度。
- **文档优先**：开始任何任务前必须先阅读并对齐以下文档——`README.md`、`docs/getting_started.md`、`docs/architecture.md`、`docs/development_plan.md`、`docs/api_reference.md`。
- 所有改动需要明确技术亮点及可量化指标（含基准数据、Profiler 截图、视频播放性能数据）。

## 工作流（文档驱动）
- 需求 -> 技术方案 -> 开发 -> 测试 -> 文档更新，链路不可缺失。
- **任务开始前**：确认任务已记录在 `docs/development_plan.md`，理解其在整体架构中的位置，并补充必要的需求/方案描述。
- **开发过程中**：遵循模块化设计，保持与既有代码一致的风格与架构边界，必要时让 Cursor 生成/校验模板代码。
- **任务完成后**：
  - 在 `docs/development_plan.md` 中将对应条目标记为 `[x]`，补充完成日期与简述。
  - 若触达架构/接口/核心流程，分别更新 `docs/architecture.md`、`docs/api_reference.md`、工作流/进度文档。
  - 记录可量化效果（播放成功率、首帧耗时、卡顿率、内存占用峰值、FPS、冷启动等）并附证据。

## 需求跟踪机制
- 任何需求、Bug、技术债都必须先写入 `docs/development_plan.md`；未登记的禁止开工。
- 完成后在清单前标记 `[x]` 并写上 `YYYY-MM-DD - done by XXX`。
- 重大变更需同步 `docs/architecture.md` 与 PR 描述，保证历史可追溯。

## 架构准则
- 强制执行模块化 + MVVM + Clean Architecture：
  - Presentation：Jetpack ViewModel、LiveData/StateFlow、Navigation，配合 BaseActivity/BaseFragment/BaseViewModel。
  - Domain：UseCase + Repository 接口，纯 Kotlin、可测试。
  - Data：Repository 实现（网络 + Room）、缓存策略、数据映射。
- **播放器抽象层**：创建统一的 `VideoPlayer` 接口，支持切换不同播放器内核（ExoPlayer/ijkplayer），便于未来扩展和维护。
- **视频播放生命周期管理**：在 ViewModel 中管理播放器状态（播放/暂停、进度、清晰度），确保生命周期安全。
- 功能按 Feature Module 拆分（视频流、个人主页、搜索等），公共能力沉淀在 `core/*`。
- 复用 Cursor 生成的标准化包结构、依赖注入骨架、Repository 模板、播放器接口，保持一致性。

## 性能与可观测性
- **播放器选型**：统一使用 ExoPlayer（Media3），支持 DASH/HLS，多码率切换、缓存与自适应码流需通过 `CacheDataSource` 与 `AdaptiveTrackSelection` 配置。
- **视频流容器**：Feed 主场景使用 `ViewPager2`（纵向）+ Paging3 + DiffUtil。`ViewPager2` 本质运行在 RecyclerView 之上，可继续沿用 `ListAdapter`、`AsyncPagingDataDiffer`。严禁全量 `notifyDataSetChanged`。
- **播放器复用池**：维护 1~3 个 ExoPlayer 实例（或全局单例 + SurfaceView 复用），通过 attach/detach 将 Surface/PlayerView 绑定到当前可见 Item。上一条离屏即 `pause/release`，下一条提前 `prepare`。
- **预加载策略**：使用 ExoPlayer 预缓冲 + `CacheDataSource` 下载前 1–2 MB，实现首帧 < 500 ms；正在播放第 N 条时，后台预加载 N+1。结合封面占位图，`onReady` 后才移除。
- **内存管理**：
  - 滑出屏幕立即释放或复用 Player，避免多个实例常驻。
  - 在 `ViewPager2` 背后 RecyclerView 的 `onViewRecycled` 中清理播放器引用、手势监听等，防止泄漏。
  - 监控内存峰值，建立缓存上限（视频缓存、封面、评论列表等）。
- **网络优化**：OkHttp + Retrofit + 协程，配置磁盘缓存、重试与弱网降级（自动降清晰度 / 提示重试）。记录成功率、重试次数。
- **初始化与可观测性**：Application 关键初始化异步化，使用 SplashScreen API。建设播放 KPI：播放成功率≥99%、首帧<500ms、卡顿率<2%、FPS 55~60、冷启动<2.5s，并通过 Profiler/指标面板记录截图。
- **日志 & 埋点**：每个手势（点赞/评论/横屏）与 AI 能力调用需埋点到 Observability 工程，便于追踪。

## 交互与动画
- **启动与导航**：遵循“Logo → 加载动画 → Feed”流程。底部/顶部 Tab 懒加载非核心 UI，保持首屏秒开体验。左右滑切换频道（推荐/关注/主页），需保证不停播切换。
- **Feed 核心**（`ViewPager2`）：
  - 上/下滑切换视频，惯性滚动与无缝切换。
  - 单击空白区显示/隐藏播控面板；双击点赞触发红心动画；长按触发倍速或 Seek 模式。
  - 滑动离开即释放上一条资源，并在进入下一条前完成预加载。
- **交互面板**：
  - 点赞/取消、收藏/取消、关注/取消均需乐观 UI 与明确反馈。
  - 评论按钮触发半屏弹层，视频缩至上半屏；评论支持 `@元宝` AI 问答。
  - 分享浮层包含复制链接与保存带二维码图片。
- **手势套件**：
  - 上下滑：切换视频；左右滑：频道切换。
  - Seek：长按 + 横向拖动，清屏展示大进度条。
  - 刷新：首页 Tab 双击或顶部下拉。
  - 倍速：长按期间 0.5×~3× 调整；松手恢复；可设置默认倍速。
- **横屏模式**：
  - 全屏按钮或旋转触发，锁定 `LANDSCAPE`，保留进度。
  - 支持亮度/音量上下滑、双击暂停、半透明控制条、倍速&清晰度菜单、防误触锁、横屏评论浮层。
  - 横屏视频列表允许上下滑查看其他横屏内容。
- **动画与触觉**：播控面板、评论浮层、点赞、刷新等均需动画与震动反馈。可使用 Lottie / MotionLayout。

## AI 融合策略（至少深耕一方向）
- **方案 A：AI 智能清晰度切换**
  - 根据实时网络/设备情况动态选择码率（自动/高清/标清），支撑弱网降级场景。
- **方案 B：AI 内容理解与推荐 / 智能互动**
  - 观看完成后本地/远端推理标签，驱动推荐；评论区 `@元宝` AI 问答基于视频标签给出答案。
- **方案 C：AI 语音识别与字幕**
  - ML Kit 生成实时字幕并与时间轴同步。
- 至少选择一个方向深度落地，明确：数据流、推理路径、在线/离线策略、模型管理、降级方案、关键指标（AI 触达率、推荐点击率、字幕延迟等）。更新 `docs/architecture.md` 与 `docs/api_reference.md` 说明。

## 工程化要求
- 统一代码规范（ktlint/Checkstyle + `.editorconfig`），引入 Git Hook 或 CI 校验。
- Git Flow / GitHub Flow：每个特性交独立分支，PR 前自测 + 自查，必要时附 Profiling 数据。
- CI（GitHub Actions 等）至少包含构建、单元测试、Lint；提交说明中标记覆盖点。
- 自动化测试：Presentation 层使用 Robolectric/Espresso 测试原生 View，Domain 层单测 UseCase，Data 层用 Fake/Mock。
- 若涉及后端/AI 服务定义，使用 Pydantic/JSON Schema（如在 docs 或脚本中）确保一致性。

## 文档更新矩阵
- `docs/architecture.md`：架构或依赖关系有变必须更新。
- `docs/api_reference.md`：接口/模型新增或变更时同步更新。
- `docs/development_plan.md`：任务状态、日期、负责人实时维护。
- `docs/getting_started.md` & `README.md`：环境、运行、亮点、阶段成果发生变化时更新。

## 工作流程示例
- **新增功能**：阅读架构/开发计划 -> 确认需求存在并补充设计 -> 基于 Clean Architecture 分层实现 -> 写/更新测试 -> 量化性能/AI指标 -> 更新所有相关文档与开发计划 -> 准备 PR 与亮点。
- **Bug 修复**：阅读相关模块设计 -> 在开发计划登记 -> 复现+定位 -> 修复并补测试 -> 若涉及架构/接口，更新文档 -> 在计划中标记完成并说明原因。

## 重要提醒
- ⚠️ 开始任何任务前必须阅读相关文档并确认任务在计划中。
- ⚠️ 每次完成任务后，立刻更新 `docs/development_plan.md` 与其它受影响文档。
- ⚠️ 任何改动都要尊重模块化与 Clean Architecture 边界，禁止"旁路"实现。
- ⚠️ **播放器是核心**：ExoPlayer 是核心组件，必须研究透彻，确保播放器生命周期管理正确，及时释放资源。
- ⚠️ **内存管理是生命线**：视频 App 最容易出问题的就是内存，时刻关注内存使用情况，使用 Profiler 监控。
- ⚠️ **交互要"无感"**：用户不应该感觉到"我在操作 App"，而应该是"我在看视频"，所有交互都要流畅、自然。
- ⚠️ 交付前整理可量化亮点（播放成功率、首帧耗时、卡顿率、内存占用、交互体验、AI 指标），确保评审一眼看到价值。

## 技术栈与运行规范
- Kotlin + Jetpack 组件（ViewModel/LiveData/StateFlow/Navigation/Paging）。
- **UI 系统**：**原生 View 系统**（TextView、ImageView、RecyclerView 等）+ **Jetpack View 组件**（ViewPager2、Navigation、MotionLayout）+ 传统 XML 布局。**注意：本项目不使用 Jetpack Compose，统一采用 Activity/Fragment + 原生 View + XML 布局。**
- **播放器**：ExoPlayer（核心，支持 DASH、HLS 等协议）。
- 数据：Room、Retrofit/OkHttp、Hilt 或 Koin。
- AI：ML Kit、TFLite 或自研推理组件。
- 构建：Gradle（优先 Kotlin DSL），CI 同步使用相同任务。
- 终端操作：首次进入终端必须执行 `cd /d D:\Projects\andriod` 并保持会话；需要构建时使用 `./gradlew` 系列命令，先 `./gradlew clean assembleDebug` 验证；如需特定环境（如 Conda/SDK），在 `README.md` 中声明并遵守。

## Cursor 使用约定
- 用 Cursor 生成标准化模板（包结构、Base 类、Repository 接口、UseCase 壳、播放器接口）、性能/交互最佳实践示例，保障一致性。
- 利用 Cursor 帮忙排查潜在瓶颈（主线程阻塞、内存泄漏、播放器资源未释放、动画过载）或快速集成 ExoPlayer/AI SDK。
- 让 Cursor 协助理解 ExoPlayer 的 API 和最佳实践，生成播放器生命周期管理代码。
- 提交前让 Cursor 列出关键优化点与亮点（特别是播放性能、内存管理、交互体验），确保价值点被记录到文档与 PR。

